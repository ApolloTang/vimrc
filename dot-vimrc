
"/ **
"/ **  first thing first
"/ **
"/ {
  set nocompatible
  set hidden          "/ Handle multiple buffers better.
                      "/ [COC] if hidden is not set, TextEdit might fail.
"}

    "/ The following are use for debugging in a sandbox
    "/ ------------------------------------------------
    " let DIR = getcwd()
    " echom DIR
    "
    " if !filereadable(DIR.'/dot-vim/plug.vim')
    "   echom 'executing curl...'
    "   silent !curl --insecure -fLo ./dot-vim/plug.vim
    "     \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    " endif
    "
    " call plug#begin(DIR.'/dot-vim/plugged')
    call plug#begin('~/.vim/plugged')
        "/ Make sure you use single quotes

        Plug 'junegunn/vim-easy-align'

        Plug 'scrooloose/nerdtree'
        Plug 'tpope/vim-surround'

        Plug 'tomtom/tcomment_vim'

        Plug 'brooth/far.vim'
            "/ Find and replace text through multiple files.



        Plug 'https://github.com/cakebaker/scss-syntax.vim'
        Plug 'https://github.com/hail2u/vim-css3-syntax'

        Plug 'vim-scripts/c.vim'
        Plug 'https://github.com/vim-scripts/applescript.vim'

        Plug 'Chiel92/vim-autoformat'

        " Plug 'cjrh/vim-conda'

        Plug 'https://github.com/vim-syntastic/syntastic'
        Plug 'mtscout6/syntastic-local-eslint.vim'

        Plug 'https://github.com/juvenn/mustache.vim'

        Plug 'https://github.com/keith/swift.vim'
        Plug 'https://github.com/TheCodedSelf/syntastic-swift'

        Plug 'https://github.com/othree/html5.vim'
        Plug 'https://github.com/digitaltoad/vim-pug'

        "/ ***
        "/ *** YouCompleteMe
        "/ ***
        " "/https://github.com/Valloric/YouCompleteMe/issues/1751
        " function! BuildYCM(info)
        "   " info is a dictionary with 3 fields
        "   " - name:   name of the plugin
        "   " - status: 'installed', 'updated', or 'unchanged'
        "   " - force:  set on PlugInstall! or PlugUpdate!
        "   if a:info.status == 'installed' || a:info.force
        "     !./install.py
        "   endif
        " endfunction
        " Plug 'Valloric/YouCompleteMe', { 'do': function('BuildYCM') }

        " Plug 'https://github.com/Quramy/tsuquyomi'
          "/ The above has duplicated function of ycm


        "/ vim-coc
        Plug 'neoclide/coc.nvim', {'branch': 'release'}



        Plug 'https://github.com/Shougo/vimproc.vim', {'do' : 'make'}
        Plug 'https://github.com/Shougo/vimshell.vim'

        "/ ***
        "/ *** Shougo/denite.nvim
        "/ ***
        Plug 'https://github.com/roxma/nvim-yarp'          "/required for denite.nvim
        Plug 'https://github.com/roxma/vim-hug-neovim-rpc' "/required for denite.nvim
        Plug 'https://github.com/Shougo/denite.nvim'

        Plug 'https://github.com/posva/vim-vue'

        Plug 'https://github.com/Konfekt/FastFold'
        Plug 'https://github.com/tmhedberg/SimpylFold'

        Plug 'https://github.com/jremmen/vim-ripgrep'

        "/ Typescript syntax
        Plug 'https://github.com/leafgarland/typescript-vim'

        "/ Flow syntax
        Plug 'https://github.com/flowtype/vim-flow'

        "/ ***
        "/ *** Jsx syntax
        "/ ***
            " Plug 'mxw/vim-jsx'
                "/ mxw/vim-jsx required pangloss/vim-javascript or yajs.vim
                "/ mxw/vim-jsx (2019 Jan) is broken and is not actively maintain

            " Plug 'https://github.com/othree/yajs.vim'
                "/ yajs is a replacement of pangloss/vim-javascript' but is out of
                "/ maintained

            " Plug 'https://github.com/othree/es.next.syntax.vim'
                "/ es.next.syntax.vim is needed for yajs.vim'

            " Plug 'https://github.com/MaxMEllon/vim-jsx-pretty'
                "/ use with yajs.vim, need to exec the follow:
                "/ $ mkdir -p ~/.vim/after/indent # if you use `nvim`, then ~/.config/nvim/after/indent
                "/ $ wget https://github.com/pangloss/vim-javascript/blob/master/indent/javascript.vim -O ~/.vim/after/indent/javascript.vim
                "/ Apollo Note: I executed as instructed above but results in error, so I removed ~/.vim/after/indent

        "/ neoclide/vim-jsx-imporve is the replacement for mxw/vim-jsx
        Plug 'neoclide/vim-jsx-improve'


        "/ Theme
        Plug 'https://github.com/morhetz/gruvbox'
        Plug 'https://github.com/ApolloTang/apollotang-light'
        Plug 'https://github.com/ApolloTang/vim-color-apollotang'

        Plug 'https://github.com/editorconfig/editorconfig-vim'

        Plug 'https://github.com/mattn/emmet-vim/'

        Plug 'https://github.com/moll/vim-bbye'
    call plug#end()


syntax enable  "/ Turn on syntax highlighting.

"/ **
"/ ** Enabling colorscheme start
"/ **
"/ Colors and fonts {

  " let g:solarized_termcolors=256
  " set t_Co=256
  " set background=dark
  " colorscheme grb256
  " colorscheme koehler
  " colorscheme apollotang
  " colorscheme apollotang-light
  " set transparency=15

  if has("gui_running")
    if has("gui_gtk2")
      " colorscheme slate
      " colorscheme apollotang
      colorscheme apollotang-light
      set guifont=Inconsolata\ 9
    elseif has("gui_macvim")
      " echo 'is macvim'
      colorscheme apollotang-light
      set guifont=Inconsolata:h14
      " set guifont=Menlo\ Regular:h14
      " set guifont=Andale\ Mono:h14
      " set guifont=Courier\ New\ Regular:h11
      " set guifont=PT\ Mono:h11
      " set guifont=Osaka-Mono:h14
      " set guifont=Monaco:h12
      " set guifont=Source\ Code\ Pro\ Light:h12
      " set guifont=Source\ Code\ Pro\ ExtraLight:h12
      " colorscheme apollotang
      " set guifont=Consolas:h12
    elseif has("gui_win32")
      set guifont=Consolas:h9:cANSI
    endif
  endif
"/} Enabling colorscheme end


"/ **
"/ ** COC configuration start
"/ **
"/  {
  "/ You will have bad experience for diagnostic messages when it's default 4000.
  set updatetime=300
  "/ don't give |ins-completion-menu| messages.
  set shortmess+=c
  "/ always show signcolumns
  set signcolumn=yes

  "/ Coc Style
  highlight CocErrorHighlight       cterm=underline gui=undercurl guisp=red    ctermfg=red
  highlight CocWarningHighlight     cterm=underline gui=undercurl guisp=orange ctermfg=3
  highlight CocInfoHighlight        cterm=underline gui=undercurl guisp=cyan1  ctermfg=cyan
  highlight CocHintHighlight        cterm=underline gui=undercurl guisp=green  ctermfg=green

  " Use tab for trigger completion with characters ahead and navigate.
  " Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
  inoremap <silent><expr> <TAB>
        \ pumvisible() ? "\<C-n>" :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ coc#refresh()
  inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

  function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~# '\s'
  endfunction

  " Use <c-space> to trigger completion.
  inoremap <silent><expr> <c-space> coc#refresh()

  " Use <cr> to confirm completion, `<C-g>u` means break undo chain at current position.
  " Coc only does snippet and additional edit on confirm.
  inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

  " Use `[c` and `]c` to navigate diagnostics
  nmap <silent> [c <Plug>(coc-diagnostic-prev)
  nmap <silent> ]c <Plug>(coc-diagnostic-next)

  " Remap keys for gotos
  nmap <silent> gd <Plug>(coc-definition)
  nmap <silent> gy <Plug>(coc-type-definition)
  nmap <silent> gi <Plug>(coc-implementation)
  nmap <silent> gr <Plug>(coc-references)

  " Use K to show documentation in preview window
  nnoremap <silent> K :call <SID>show_documentation()<CR>

  function! s:show_documentation()
    if (index(['vim','help'], &filetype) >= 0)
      execute 'h '.expand('<cword>')
    else
      call CocAction('doHover')
    endif
  endfunction

  " Highlight symbol under cursor on CursorHold
  autocmd CursorHold * silent call CocActionAsync('highlight')

  " Remap for rename current word
  nmap <space>crn <Plug>(coc-rename)

  " Open refactor window for refactor of current symbol
  nmap <space>crf <Plug>(coc-refactor)

  " Remap for format selected region
  xmap <leader>f  <Plug>(coc-format-selected)
  nmap <leader>f  <Plug>(coc-format-selected)

  augroup mygroup
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
  augroup end

  " Remap for do codeAction of selected region, ex: `<leader>aap` for current paragraph
  xmap <leader>a  <Plug>(coc-codeaction-selected)
  nmap <leader>a  <Plug>(coc-codeaction-selected)

  " Remap for do codeAction of current line
  nmap <leader>ac  <Plug>(coc-codeaction)
  " Fix autofix problem of current line
  nmap <leader>qf  <Plug>(coc-fix-current)

  " Use <tab> for select selections ranges, needs server support, like: coc-tsserver, coc-python
  nmap <silent> <TAB> <Plug>(coc-range-select)
  xmap <silent> <TAB> <Plug>(coc-range-select)
  xmap <silent> <S-TAB> <Plug>(coc-range-select-backword)

  " Use `:Format` to format current buffer
  command! -nargs=0 Format :call CocAction('format')

  " Use `:Fold` to fold current buffer
  command! -nargs=? Fold :call     CocAction('fold', <f-args>)

  " use `:OR` for organize import of current buffer
  command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

  " Add diagnostic info for https://github.com/itchyny/lightline.vim
  let g:lightline = {
        \ 'colorscheme': 'wombat',
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ],
        \             [ 'cocstatus', 'readonly', 'filename', 'modified' ] ]
        \ },
        \ 'component_function': {
        \   'cocstatus': 'coc#status'
        \ },
        \ }

  " Using CocList
  " Show all diagnostics
  nnoremap <silent> <space>a  :<C-u>CocList diagnostics<cr>
  " Manage extensions
  nnoremap <silent> <space>e  :<C-u>CocList extensions<cr>
  " Show commands
  nnoremap <silent> <space>c  :<C-u>CocList commands<cr>
  " Find symbol of current document
  nnoremap <silent> <space>o  :<C-u>CocList outline<cr>
  " Search workspace symbols
  nnoremap <silent> <space>s  :<C-u>CocList -I symbols<cr>
  " Do default action for next item.
  nnoremap <silent> <space>j  :<C-u>CocNext<CR>
  " Do default action for previous item.
  nnoremap <silent> <space>k  :<C-u>CocPrev<CR>
  " Resume latest coc list
  nnoremap <silent> <space>p  :<C-u>CocListResume<CR>

"/ } COC configuration end



"/ **
"/ ** vim-flow configuration start
"/ **
"/  {

  "/ This is to fix this bug: https://github.com/flowtype/vim-flow/issues/38#issuecomment-266044794
    let g:flow#autoclose = 1
    "/ If g:flow#autoclose is set to 1, the quickfix window will not be opened
    "/ when there are no errors, and will be automatically closed when previous errors are cleared.

"/ } vim-flow configuration end



    "/ junegunn/vim-easy-align {
        "/ Start interactive EasyAlign in visual mode (e.g. vipga)
        xmap ga <Plug>(EasyAlign)
        "/ Start interactive EasyAlign for a motion/text object (e.g. gaip)
        nmap ga <Plug>(EasyAlign)
    "/ }

    "/ mxw/vim-jsx {
        "/ treat .js as .jsx
        let g:jsx_ext_required = 0
    "/ }

    "/ keith/swift.vim {
      let g:syntastic_swift_checkers = ['swiftpm', 'swiftlint']
    "/ }


    "/ **
    "/ ** Shougo/denite.nvim configuration
    "/ **
    "/ Shougo/denite.nvim {

      "/ Ref: https://github.com/ctaylo21/jarvis/blob/master/config/nvim/init.vim
      "/
      "/ === Denite setup ==="
      "/ Use ripgrep for searching current directory for files
      "/ By default, ripgrep will respect rules in .gitignore
      "/   --files: Print each file that would be searched (but don't search)
      "/   --glob:  Include or exclues files for searching that match the given glob
      "/            (aka ignore .git files)
      "/

      call denite#custom#var('file/rec', 'command', ['rg', '--files', '--glob', '!.git'])

      "/ Use ripgrep in place of "grep"
      call denite#custom#var('grep', 'command', ['rg'])

      "/ Custom options for ripgrep
      "/   --vimgrep:  Show results with every match on it's own line
      "/   --hidden:   Search hidden directories and files
      "/   --heading:  Show the file name above clusters of matches from each file
      "/   --S:        Search case insensitively if the pattern is all lowercase
      call denite#custom#var('grep', 'default_opts', ['--hidden', '--vimgrep', '--heading', '-S'])

      "/ Recommended defaults for ripgrep via Denite docs
      call denite#custom#var('grep', 'recursive_opts', [])
      call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
      call denite#custom#var('grep', 'separator', ['--'])
      call denite#custom#var('grep', 'final_opts', [])

      "/ Remove date from buffer list
      call denite#custom#var('buffer', 'date_format', '')

      "/ Open file commands
      call denite#custom#map('insert,normal', "<C-t>", '<denite:do_action:tabopen>')
      call denite#custom#map('insert,normal', "<C-v>", '<denite:do_action:vsplit>')
      call denite#custom#map('insert,normal', "<C-h>", '<denite:do_action:split>')

      "/ Custom options for Denite
      "/   auto_resize             - Auto resize the Denite window height automatically.
      "/   prompt                  - Customize denite prompt
      "/   direction               - Specify Denite window direction as directly below current pane
      "/   winminheight            - Specify min height for Denite window
      "/   highlight_mode_insert   - Specify h1-CursorLine in insert mode
      "/   prompt_highlight        - Specify color of prompt
      "/   highlight_matched_char  - Matched characters highlight
      "/   highlight_matched_range - matched range highlight
      let s:denite_options = {'default' : {
      \ 'auto_resize': 1,
      \ 'prompt': 'λ:',
      \ 'direction': 'rightbelow',
      \ 'winminheight': '10',
      \ 'highlight_mode_insert': 'Visual',
      \ 'highlight_mode_normal': 'Visual',
      \ 'prompt_highlight': 'Function',
      \ 'highlight_matched_char': 'Function',
      \ 'highlight_matched_range': 'Normal'
      \ }}

      "/ Loop through denite options and enable them
      function! s:profile(opts) abort
        for l:fname in keys(a:opts)
          for l:dopt in keys(a:opts[l:fname])
            call denite#custom#option(l:fname, l:dopt, a:opts[l:fname][l:dopt])
          endfor
        endfor
      endfunction
      call s:profile(s:denite_options)

      "/ Denite-mappings
      "/ ---------------

        "/  <space>db  - Browser currently open buffers
        "/  <space>df  - Browse list of files in current directory
        "/  <space>dg  - Search current directory for occurences of given term and
        "/               close window if no results
        "/  <space>dc  - Search current directory for occurences of word under cursor
        nmap <space>db :Denite buffer -split=floating -winrow=1<CR>
        nmap <space>df :Denite file/rec -split=floating -winrow=1<CR>
        " nnoremap <leader>g :<C-u>Denite grep:. -no-empty<CR> "/ not sure what ':.' does
        nnoremap <space>dg :<C-u>Denite grep -no-empty<CR>
        " nnoremap <leader>j :<C-u>DeniteCursorWord grep:.<CR> "/ not sure what ':.' does
        nnoremap <space>dc :<C-u>DeniteCursorWord grep<CR>

        autocmd FileType denite call s:denite_my_settings()
        function! s:denite_my_settings() abort
          nnoremap <silent><buffer><expr> <CR> denite#do_map('do_action')
          nnoremap <silent><buffer><expr> d denite#do_map('do_action', 'delete')
          nnoremap <silent><buffer><expr> p denite#do_map('do_action', 'preview')
          nnoremap <silent><buffer><expr> q denite#do_map('quit')
          nnoremap <silent><buffer><expr> i denite#do_map('open_filter_buffer')
          nnoremap <silent><buffer><expr> <Space> denite#do_map('toggle_select').'j'
        endfunction

    "/ } Shougo/denite.nvim END


    "/ Konfekt/FastFold {
      let g:fastfold_savehook = 0 " update folds manually
      let g:fastfold_fold_command_suffixes = [] " use standard folding keystroke

      let g:markdown_folding = 1
      let g:tex_fold_enabled = 1
      let g:vimsyn_folding = 'af'
      let g:xml_syntax_folding = 1
      let g:javaScript_fold = 1
      let g:sh_fold_enabled= 7
      let g:ruby_fold = 1
      let g:perl_fold = 1
      let g:perl_fold_blocks = 1
      let g:r_syntax_folding = 1
      let g:rust_fold = 1
      let g:php_folding = 1
    "/ }

    "/ tmhedberg/SimpylFold {
      let g:SimpylFold_docstring_preview = 1 " 0=disable; 1=enable
    "/ }

    "/ MaxMEllon/vim-jsx-pretty {
      let g:vim_jsx_pretty_enable_jsx_highlight = 1 " default 1
    "/ }
" }

" call pathogen#infect()

" Environment {
    " Identify platform {
        silent function! OSX()
            return has('macunix')
        endfunction
        silent function! LINUX()
            return has('unix') && !has('macunix') && !has('win32unix')
        endfunction
        silent function! WINDOWS()
            return  (has('win16') || has('win32') || has('win64'))
        endfunction
    " }

    " Basics {
        if !WINDOWS()
            set shell=/bin/sh
        endif
        " set shell=bash
        "/ previously use use the above line, not sure what window
    " }

    " Windows Compatible {
        "/ On Windows, also use '.vim' instead of 'vimfiles'; this makes synchronization
        "/ across (heterogeneous) systems easier.
        if WINDOWS()
            set winaltkeys=yes
            "/ set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
        endif
    " }

    "/ For ssh session
    "set term=cons25
    "/ The above fix displaying A B C D on remote shell on pressing arrow key
    "/ http://vim.wikia.com/wiki/Fix_arrow_keys_that_display_A_B_C_D_on_remote_shel
" }


" Python Setting {
  set pythondll=/usr/local/Frameworks/Python.framework/Versions/3.7/Python
  set pythonhome=/usr/local/Frameworks/Python.framework/Versions/3.7
  set pythonthreedll=/usr/local/Frameworks/Python.framework/Versions/3.7/Python
  set pythonthreehome=/usr/local/Frameworks/Python.framework/Versions/3.7
" }

"/ Essential Customization { ---------------------------------------------
  noremap <c-q> :q<CR>
"/}

" Setting to sort { ------------------------------------------------------
    let mapleader=","
    let maplocalleader="\\"                 "\ leader that targat specific file type

    " inoremap <leader><leader> <Esc>hhhh     "\ back to normal mode; the 4h (hhhh) fix cusor jump around
    inoremap ,, <Esc>l
    vnoremap ,, <Esc>

    filetype plugin indent on               " Turn on file type detection.

    runtime macros/matchit.vim              " Load the matchit plugin.

    set showcmd                             " Display incomplete commands.
    set showmode                            " Display the mode you're in.

    set backspace=indent,eol,start          " Intuitive backspacing.
    "set whichwrap+=<,>,h,l                 " what is this?

    set history=1000                        " Rememember more commands and search history
    set wildmenu                            " Enhanced command line completion.
    set wildmode=list:longest               " Complete files like a shell.

    set ignorecase                          " Case-insensitive searching.
    set smartcase                           " But case-sensitive if expression contains a capital letter.

    set number                              " Show line numbers.
    set ruler                               " Show cursor position.
    set relativenumber                      " use relative number

    set incsearch                           " Highlight matches as you type.
    set hlsearch                            " Highlight matches.

    " set scrolloff=3                       " Show 3 lines of context around the cursor.
    set scrolloff=0                         " Show 0 lines of context around the cursor.

    set title                               " Set the terminal's title

    set autoread                            " auto read when a file is changed from outside

    "/ [COC] Some servers have issues with backup files
    "/       and required to set nobackup and nowritebackup
    "/       see https://github.com/neoclide/coc.nvim/issues/649
    "/ note: I have set both nobackup and nowritebackup before COC
      set nobackup
      set nowritebackup

    set noswapfile                          " no swap files
    "set directory=$HOME/.vim/tmp//,.       " Keep swap files in one location


    set nocursorline                        " do not show cursor line
    set cmdheight=2
    set switchbuf=useopen
    "set numberwidth=5
    set showtabline=2
    "set winwidth=150                       " do not set width, if set window will size it self
    set winheight=6
    set winminheight=5

    "/ Display trailing white= spaces
    set encoding=utf-8
    set list
    set listchars=
      \tab:·\ , "/ note there is a space before comma
      \trail:·,
      " \eol:¬


    "\ ---------------
    "\  Status line
    "\ ---------------

    set laststatus=2                        " Show the status line all the time

    function! WindowNumber()
        "\ Get number number.
        "\ http://stackoverflow.com/questions/6403716/shortcut-for-moving-between-vim-windows
        let str=tabpagewinnr(tabpagenr())
        return str
    endfunction

    "\ Status information at bottom of screen
    "\ Ref: https://stackoverflow.com/questions/4390011/how-do-you-write-text-on-the-status-line-with-the-filename-row-and-col-number-w
    "\
    " set statusline=[%n]\ %<%.99f\ %h%w%m%r%y\ %{exists('*CapsLockStatusline')?CapsLockStatusline():''}%=%-16(\ %l,%c-%v\ %)%P
    set statusline=%n\|%{WindowNumber()}\|%<%.99f\ %=%10(%H%W%M%R\|%p%%\|%l\|%c\|%v\%)

    "\ ---------------
    "\  Status color
    "\ ---------------
    "\ Status line color based on mode
    "\ http://stackoverflow.com/questions/9065941/how-can-i-change-vim-status-line-colour
    "\ http://vimdoc.sourceforge.net/htmldoc/syntax.html#:highlight
    "\ http://vim.wikia.com/wiki/Change_statusline_color_to_show_insert_or_normal_mode

    " if version >= 700
    "   au InsertEnter * hi StatusLine cterm=bold,reverse ctermbg=2 ctermfg=15 gui=reverse guifg=gray50 guibg=cyan
    "   au InsertLeave * hi StatusLine cterm=bold,reverse ctermbg=0 ctermfg=15 gui=reverse guifg=gray50 guibg=black
    " endif

    function! InsertStatuslineColor(mode)
      if a:mode == 'i'
        hi statusline guibg=black ctermfg=11 guifg=gold ctermbg=0
      elseif a:mode == 'r'
        hi statusline guibg=white ctermfg=9 guifg=sienna ctermbg=0
      else
        hi statusline guibg=red ctermfg=1 guifg=red ctermbg=0
      endif
    endfunction

    if version >= 700
      au InsertEnter * call InsertStatuslineColor(v:insertmode)
      au InsertChange * call InsertStatuslineColor(v:insertmode)
      " au InsertLeave * hi statusline guibg=white ctermfg=8 guifg=gray50 ctermbg=15
      " au InsertLeave * hi statusline guibg=DarkGrey ctermfg=8 guifg=White ctermbg=15
      au InsertLeave * hi StatusLine cterm=reverse ctermbg=0 ctermfg=14 guifg=darkCyan guibg=white
    endif

    " default the statusline when entering Vim, work on terminal vim but it has no effect on macvim
    hi statusline guibg=white ctermfg=14 guifg=darkCyan ctermbg=0


    "\ ---------------
    "\  Sound
    "\ ---------------
    " No sound on errors
    set noerrorbells
    "set visualbell                    " No beeping.
    set novisualbell                   " No flashing
    set tm=500
    "/ disable bell in mac. http://stackoverflow.com/questions/16047146/disable-bell-in-macvim
    autocmd! GUIEnter * set vb t_vb=


    "/ rainbow:  https://github.com/luochen1990/rainbow
    "let g:rainbow_active = 0 "0 if you want to enable it later via :RainbowToggle

" }



" Syntax highlight { ------------------------------------------------------
    map <F6> :echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "name")
    "/ The above tell you "what kind syntax ID that it is thing under the given position"
    "/ http://linuxyz.blogspot.ca/search/label/VIM
" }

" Indentation setting { --------------------------------------------------
    "set noexpandtab                  " do not use space as tabs
    set expandtab                    " use space as tabs

    set tabstop=2                    " Global tab width.
    set shiftwidth=2                 " And again, related.
    set softtabstop=2

    "/ The following snippet of vimscript allows you to assign
    "/ the same value to tabstop, softtabstop and shiftwidth
    "/ simultaneously.
    command! -nargs=* Stab call Stab()
    function! Stab()
        let l:tabstop = 1 * input('set tabstop = softtabstop = shiftwidth = ')
        if l:tabstop > 0
            let &l:sts = l:tabstop
            let &l:ts = l:tabstop
            let &l:sw = l:tabstop
        endif
        call SummarizeTabs()
    endfunction

    function! SummarizeTabs()
        try
            echohl ModeMsg
            echon 'tabstop='.&l:ts
            echon ' shiftwidth='.&l:sw
            echon ' softtabstop='.&l:sts
            if &l:et
                echon ' expandtab'
            else
                echon ' noexpandtab'
            endif
        finally
            echohl None
        endtry
    endfunction
    "/ To invoke Stab(), go into normal mode (by pressing
    "/ escape) then run:
    "/      :Stab
    "/ Then hit enter. You will see this:
    "/      set tabstop = softtabstop = shiftwidth =
    "/ Enter the size that you want to assign to those settings
    "/ and hit enter.  A summary line then shows the value of
    "/ each setting, as well as showing whether or not expandtab
    "/ is enabled. If you hit enter without providing a value
    "/ then the tab settings are not affected.
    "/
    "/ ref: http://vimcasts.org/episodes/tabs-and-spaces/

    "/ Indentation short cut:
    vmap << <gv
    vmap >> >gv
" }

" JSHint setting {
    "/ https://github.com/Shutnik/jshint2.vim

    " Plateform pattern {
        "   if !WINDOWS()
        "       "echom 'Runtime envrionment: Not windows'
        "   endif
    "   if WINDOWS()
    "       echom 'Runtime envrionment: Windows'
    "       let jshint2_command = '~/path/to/node_mobules/.bin/jshint'
    "   endif
        "   if OSX()
        "       "echom 'Runtime envrionment: OSX'
        "   endif
        "   if LINUX()
        "       "echom 'Runtime envrionment: Linux'
        "   endif
    " }

    " jshint validation
    nnoremap <silent><F1> :JSHint<CR>
    inoremap <silent><F1> <C-O>:JSHint<CR>
    vnoremap <silent><F1> :JSHint<CR>

    " show next jshint error
    nnoremap <silent><F2> :lnext<CR>
    inoremap <silent><F2> <C-O>:lnext<CR>
    vnoremap <silent><F2> :lnext<CR>

    " show previous jshint error
    nnoremap <silent><F3> :lprevious<CR>
    inoremap <silent><F3> <C-O>:lprevious<CR>
    vnoremap <silent><F3> :lprevious<CR>
" }

"\ Terminal in vim {
  "\ https://stackoverflow.com/a/46822285/3136861

  tnoremap <ESC><ESC> <C-\><C-N>
  "\ The above allow hitting ESC twice exit exit terminal mode back to normal-mode
  "\ https://stackoverflow.com/a/29293191/3136861

  "/ The next line causes Lsp to crush !!! so commented out
  "set shell=bash\ --login
  "\ The above will load my .bashrc when :term
  "\ https://stackoverflow.com/questions/1694599/how-do-i-get-vims-sh-command-to-source-my-bashrc
"}


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" CUSTOM AUTOCMDS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

augroup vimrcEx
" Clear all autocmds in the group
autocmd!

"autocmd FileType text setlocal textwidth=78

" Jump to last cursor position unless it's invalid or in an event handler
autocmd BufReadPost *
\ if line("'\"") > 0 && line("'\"") <= line("$") |
\ exe "normal g`\"" |
\ endif

au BufNewFile,BufRead *.jade set filetype=pug
au BufRead,BufNewFile *.sass set filetype=sass

"for ruby, autoindent with two spaces, always expand tabs
"autocmd FileType ruby,haml,eruby,yaml,html,javascript,sass,cucumber set ai sw=2 sts=2 et
autocmd FileType sass, scss set ai sw=2,sts=2 et
autocmd FileType jade set ai sw=2,sts=2 et

"/ Syntax for python
"autocmd FileType python set sw=4 sts=4 et
au BufNewFile,BufRead *.py set ts=4 sts=4 sw=4 ai et filetype=python
"/ Ref: https://realpython.com/vim-and-python-a-match-made-in-heaven/


"/ Syntax for coffee script:
"/ https://github.com/kchmck/vim-coffee-script
"/ http://stackoverflow.com/questions/5602767/why-is-vim-not-detecting-my-coffescript-filetype
autocmd BufNewFile,BufRead *.coffee set filetype=coffee
autocmd FileType coffee set ai sw=2 sts=2 et

"/ Syntax for JavaScript
"/ to use in conjunction with Syntax folding for Javascript, but is crap so
"/  comment out.
"autocmd BufNewFile,BufRead *.js set filetype=javascript


autocmd BufRead *.mkd set ai formatoptions=tcroqn2 comments=n:&gt;
autocmd BufRead *.markdown set ai formatoptions=tcroqn2 comments=n:&gt;

" Indent p tags
"autocmd FileType html,eruby if g:html_indent_tags !~ '\\|p\>' | let g:html_indent_tags .= '\|p\|li\|dt\|dd' | endif

" Don't syntax highlight markdown because it's often wrong
autocmd! FileType mkd setlocal syn=off

" recompile coffeescript files on write
" au BufWritePost *.coffee silent CoffeeMake! -b | cwindow | redraw!
augroup END

function! FtHtml()
  set filetype=html
  set filetype?
endfunction "/ FtHtml()
command! CftHtml call FtHtml()


" Code folding {----------------------------------------------------------
    set fdm=indent

    " highlight Folded guibg=black        " color for codefolding line
    " highlight Folded guibg=gray14       " color for codefolding line
    " highlight Folded guifg=gray25 guibg=gray10
    "/ syntax color is set in colorscheme, so above is commented out

    "/ All folds are closed by default, the following set the initial folding level
    "/ http://vim.wikia.com/wiki/All_folds_open_when_opening_a_file
    set foldlevelstart=20

    "/ Syntax folding for Javascript
    "/ https://github.com/jelera/vim-javascript-syntax
    "/ this is crap, so commented out!
    "au FileType javascript call JavaScriptFold()
" }



" MISC KEY MAPS ----------------------------------------------------------

command! W :wa
"command! Q :q
"command! WQ :wq


" Window resizing mappings { ----------------------------------------
  "/ http://vim.wikia.com/wiki/Fast_window_resizing_with_plus/minus_keys
  nnoremap <S-Up> :normal <c-r>=Resize('+')<CR><CR>
  nnoremap <S-Down> :normal <c-r>=Resize('-')<CR><CR>
  nnoremap <S-Left> :normal <c-r>=Resize('<')<CR><CR>
  nnoremap <S-Right> :normal <c-r>=Resize('>')<CR><CR>

  function! Resize(dir)
    let this = winnr()
    if '+' == a:dir || '-' == a:dir
      execute "normal \<c-w>k"
      let up = winnr()
      if up != this
        execute "normal \<c-w>j"
        let x = 'bottom'
      else
        let x = 'top'
      endif
    elseif '>' == a:dir || '<' == a:dir
      execute "normal \<c-w>h"
      let left = winnr()
      if left != this
        execute "normal \<c-w>l"
        let x = 'right'
      else
        let x = 'left'
      endif
    endif
    if ('+' == a:dir && 'bottom' == x) || ('-' == a:dir && 'top' == x)
      return "1\<c-v>\<c-w>+"
    elseif ('-' == a:dir && 'bottom' == x) || ('+' == a:dir && 'top' == x)
      return "1\<c-v>\<c-w>-"
    elseif ('<' == a:dir && 'left' == x) || ('>' == a:dir && 'right' == x)
      return "1\<c-v>\<c-w><"
    elseif ('>' == a:dir && 'left' == x) || ('<' == a:dir && 'right' == x)
      return "1\<c-v>\<c-w>>"
    else
      echo "oops. check your ~/.vimrc"
      return ""
    endif
  endfunction
"}


    """"""""""""""""""""""""""""""""""""""""""
    " OPEN FILES IN DIRECTORY OF CURRENT FILE
    """"""""""""""""""""""""""""""""""""""""""
    cnoremap %% <C-R>=expand('%:h').'/'<cr>
    map <leader>e :edit %%
    map <leader>d :view %%


    """"""""""""""""""""""
    " RENAME CURRENT FILE
    """"""""""""""""""""""
    function! RenameFile()
      let old_name = expand('%')
      let new_name = input('New file name: ', expand('%'))
      if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
      endif
    endfunction
    nnoremap <leader>fr :call RenameFile()<cr>


" window { ---------------------------------------------------------------
    " ##  Window resizing
    nnoremap <leader>ww 30<c-w>>
    nnoremap <leader>nn 30<c-w><

    nnoremap <leader>www 30<c-w>+
    nnoremap <leader>nnn 30<c-w>-


    " ## Move around splits
    nnoremap <c-j> <c-w>j
    nnoremap <c-k> <c-w>k
    nnoremap <c-h> <c-w>h
    nnoremap <c-l> <c-w>l

    " ## Move around splits
    " nnoremap <leader>j <c-w>j
    " nnoremap <leader>k <c-w>k
    " nnoremap <leader>h <c-w>h
    " nnoremap <leader>l <c-w>l

    "\ ----------------
    "\  Jump to window
    "\ ----------------
    "\ http://stackoverflow.com/questions/6403716/shortcut-for-moving-between-vim-windows
    let i = 1
    while i <= 19
        execute 'nnoremap <Leader>' . i . ' :' . i . 'wincmd w<CR>'
        let i = i + 1
    endwhile
" }

"/ Interact with shell { --------------------------------------------------
    "/ Next command open Terminal at pwd via npm module 'ttab'
    "/ to install ttab: sudo npm install ttab -g
    command! -nargs=* Term !ttab -d `pwd`
"/ }

"/ ## scrolling horizontal { ------------------------------------------------
    "/ No scrolling for now, need a solution
        " nmap <s-l> zl  "scroll left
        " nmap <s-h> zh  "scroll right
"/ }

" ## Wrapping behaviour { ------------------------------------------------
    set nowrap nolinebreak list
    command! -nargs=* Wrapword set wrap linebreak nolist
    command! -nargs=* Wrap set wrap list
    command! -nargs=* Wrapoff set nowrap nolinebreak list

    " ## Break long line at 60 col
    nnoremap <leader>y 060lf i<CR><ESC>

    "/ mapping to make movements operate on 1 screen line in wrap mode
    function! ScreenMovement(movement)
      let b:gmove = "yes"     "<---- added to fix error during Wrapword
      if &wrap && b:gmove == 'yes'
        return "g" . a:movement
      else
        return a:movement
      endif
    endfunction
    onoremap <silent> <expr> j ScreenMovement("j")
    onoremap <silent> <expr> k ScreenMovement("k")
    onoremap <silent> <expr> 0 ScreenMovement("0")
    onoremap <silent> <expr> ^ ScreenMovement("^")
    onoremap <silent> <expr> $ ScreenMovement("$")
    nnoremap <silent> <expr> j ScreenMovement("j")
    nnoremap <silent> <expr> k ScreenMovement("k")
    nnoremap <silent> <expr> 0 ScreenMovement("0")
    nnoremap <silent> <expr> ^ ScreenMovement("^")
    nnoremap <silent> <expr> $ ScreenMovement("$")
    vnoremap <silent> <expr> j ScreenMovement("j")
    vnoremap <silent> <expr> k ScreenMovement("k")
    vnoremap <silent> <expr> 0 ScreenMovement("0")
    vnoremap <silent> <expr> ^ ScreenMovement("^")
    vnoremap <silent> <expr> $ ScreenMovement("$")
    vnoremap <silent> <expr> j ScreenMovement("j")
    " toggle showbreak
    function! TYShowBreak()
      if &showbreak == ''
        set showbreak=>
      else
        set showbreak=
      endif
    endfunction
    let b:gmove = "yes"
    function! TYToggleBreakMove()
      if exists("b:gmove") && b:gmove == "yes"
        let b:gmove = "no"
      else
        let b:gmove = "yes"
      endif
    endfunction
    nmap  <expr> ,b  TYShowBreak()
    nmap  <expr> ,bb  TYToggleBreakMove()
    "/ ref: http://superuser.com/questions/498267/how-do-you-move-up-within-a-single-line-thats-word-wrapped-in-vim

" }


" Inserting stuff { --------------------------------------------------------
    " ## Insert a hash rocket with <c-l>l
    imap <c-l>l <space>=><space>

    "/ == Digraph remapping ==
    "/ Since <c-k> has inoremap to insert mode's movement
    "/ for a list of digraph-key type ":help digraph-table-mbyte"
    inoremap <leader>k <c-k>
"}

" Clear the search buffer when hitting return
:nnoremap <CR> :nohlsearch<cr>
"nnoremap <leader><leader> <c-^>


"/ Map braces and brackets
imap [ []<left>
imap ( ()<left>
imap { {}<left>

" Open line (insert mode)
inoremap <leader>O <esc>O
inoremap <leader>o <esc>o
" Open line (normal mode)
nnoremap <leader>O O<esc>
nnoremap <leader>o o<esc>

"/ emacs like begin and end of line
inoremap <c-a> <esc>^i
inoremap <c-e> <esc>A

"/ insert mode movements
inoremap <c-j> <down>
inoremap <c-k> <up>
inoremap <c-l> <right>
inoremap <c-h> <left>

"/ moving aroung in command mode
"/ https://stackoverflow.com/a/15852162/3136861
cnoremap <c-h> <left>
cnoremap <c-l> <right>

"/ go to middle of current line
"/ http://superuser.com/questions/216411/go-to-middle-of-line-in-vim
map gm :call cursor(0, virtcol('$')/2)<CR>


" ##  Line Bubling (map to unimpaired plugin)
nmap <C-Up>   [e`[            " Bubling up one line
nmap <C-Down> ]e`[            " Bubling down one line
"nnoremap <C-Up> V:move '<-2<CR><Esc>0        " Bubble up one lines (after select with visual mode)
"nnoremap <C-Down> V:move '>+1<CR><Esc>0        " Bubble down one lines (after select with visual mode)


" cut and paste { --------------------------------------------------------
    " Plateform specific {
        if !WINDOWS()
        endif
        if WINDOWS()
            set clipboard=unnamed
        endif
        if OSX()
        endif
        if LINUX()
            set clipboard=unnamedplus
        endif
    " }

    " https://stackoverflow.com/a/11020240/3136861
    " set clipboard+=autoselect
    " set guioptions+=a

    " yank to clipboard
    map <c-b> "*y

    " paste clipboard under cursor
    nnoremap <c-f> "*P
    vnoremap <c-f> "*P

    " paste previous yank under cursor
    nnoremap <c-g> "0P
    vnoremap <c-g> "0P

    "/ paste clipboard *after* cursor
    "nnoremap <leader>f "*p
    "vnoremap <leader>f "*p
    "/     leader-f is conflicting with [coc] formate select region
    "/     so it is commented out.

    " paste previous yank *after* cursor
    nnoremap <leader>g "0p
    vnoremap <leader>g "0p
"}


" Remove trailing spaces { -----------------------------------------------
    " Old version of remove trailing spaces {
        "/ ref http://www.bestofvim.com/tip/trailing-whitespace/
        " nnoremap <Leader>rtw :%s/\s\+$//e<CR>
        " function! TrimWhiteSpace()
        "     %s/\s\+$//e
        " endfunction
        " nnoremap <silent> <Leader>rts :call TrimWhiteSpace()<CR>
        " autocmd FileWritePre    * :call TrimWhiteSpace()
        " autocmd FileAppendPre   * :call TrimWhiteSpace()
        " autocmd FilterWritePre  * :call TrimWhiteSpace()
        " autocmd BufWritePre     * :call TrimWhiteSpace()
    " } End Old version of remove trailing spaces

    "/ ref: http://vimcasts.org/episodes/tidying-whitespace/
    function! <SID>StripTrailingWhitespaces()
        "/ Preparation: save last search, and cursor position.
        let _s=@/
        let l = line(".")
        let c = col(".")
        "/ Do the business:
        %s/\s\+$//e
        "/ Clean up: restore previous search history, and cursor position
        let @/=_s
        call cursor(l, c)
    endfunction
    nnoremap <silent> <leader>stw :call <SID>StripTrailingWhitespaces()<CR>
    autocmd BufWritePre *.py,*.xml,*,txt,*.html,*.sass,*.css,*.js :call <SID>StripTrailingWhitespaces()
" } End :: Remove trailing spaces



" Create current directory path
":nnoremap <leader>m :!mkdir -p %:h
"let g:ragtag_global_maps = 1


" { edit .vimrc file ------------------------------------------------------
    nnoremap <leader>ev :vsplit $MYVIMRC<cr>
    nnoremap <leader>sv :source $MYVIMRC<cr>
" }

" Novice arrow disable { --------------------------------------------------
    " map <Left>  :echo "             do not use arrow key!"<cr>
    " map <Right> :echo "             do not use arrow key!"<cr>
    " map <Up>    :echo "             do not use arrow key!"<cr>
    " map <Down>  :echo "             do not use arrow key!"<cr>
" }


" search and replace helper  { --------------------------------------------
    noremap ;' :%s:::g<Left><Left><Left>
    noremap ;; :%s:::cg<Left><Left><Left><Left>
    "/ These mappings save you some keystrokes and put you where you start typing
    "/ your search pattern. After typing it you move to the replacement part , type
    "/ it and hit return. The second version adds confirmation flag.
" }


" Stuff to figure out { --------------------------------------------------
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " MULTIPURPOSE TAB KEY
    " Indent if we're at the beginning of a line. Else, do completion.
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " function! InsertTabWrapper()
    "   let col = col('.') - 1
    "   if !col || getline('.')[col - 1] !~ '\k'
    "     return "\<tab>"
    "     else
    "     return "\<c-p>"
    "   endif
    " endfunction
    "/ ***
    "/ *** the following is conflicting with asyncomplete so commented out
    "/ ***
      " inoremap <tab> <c-r>=InsertTabWrapper()<cr>
      " inoremap <s-tab> <c-n>





    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " PROMOTE VARIABLE TO RSPEC LET
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " function! PromoteToLet()
    "   :normal! dd
    "   " :exec '?^\s*it\>'
    "   :normal! P
    "   :.s/\(\w\+\) = \(.*\)$/let(:\1) { \2 }/
    "   :normal ==
    " endfunction
    " :command! PromoteToLet :call PromoteToLet()
    " :map <leader>pm :PromoteToLet<cr>



    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " MAPS TO JUMP TO SPECIFIC COMMAND-T TARGETS AND FILES
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    " map <leader>gr :topleft :split config/routes.rb<cr>

    " function! ShowRoutes()
    "   "/ Requires 'scratch' plugin
    "   :topleft 100 :split __Routes__
    "   "/ Make sure Vim doesn't write __Routes__ as a file
    "   :set buftype=nofile
    "   "/ Delete everything
    "   :normal 1GdG
    "   "/ Put routes output in buffer
    "   :0r! bundle exec rake -s routes
    "   "/ Size window to number of lines (1 plus rake output length)
    "   :exec ":normal " . line("$") . "_ "
    "   "/ Move cursor to bottom
    "   :normal 1GG
    "   "/ Delete empty trailing line
    "   :normal dd
    " endfunction
    " map <leader>gR :call ShowRoutes()<cr>

    " map <leader>gv :CommandTFlush<cr>\|:CommandT app/views<cr>
    " map <leader>gc :CommandTFlush<cr>\|:CommandT app/controllers<cr>
    " map <leader>gm :CommandTFlush<cr>\|:CommandT app/models<cr>
    " map <leader>gh :CommandTFlush<cr>\|:CommandT app/helpers<cr>
    " map <leader>gl :CommandTFlush<cr>\|:CommandT lib<cr>
    " map <leader>gp :CommandTFlush<cr>\|:CommandT public<cr>
    " map <leader>gs :CommandTFlush<cr>\|:CommandT public/stylesheets/sass<cr>
    " map <leader>gf :CommandTFlush<cr>\|:CommandT features<cr>
    " map <leader>gg :topleft 100 :split Gemfile<cr>
    " map <leader>gt :CommandTFlush<cr>\|:CommandTTag<cr>
    "map <leader>f :CommandTFlush<cr>\|:CommandT<cr>
    "map <leader>F :CommandTFlush<cr>\|:CommandT %%<cr>

    ",tags directory
    "set tags=./tags;
    " map <leader>rt :!ctags --extra=+f --exclude=.git --exclude=log --exclude=tags --exclude=doc -R * `rvm gemdir`/bundler/gems/*<CR><C-M>
    " map <leader>rt :!ctags --extra=+f --exclude=.git --exclude=log --exclude=tags --exclude=doc --exclude=public -R * `rvm gemdir`/bundler/gems/*<CR><C-M>
    " map <leader>rt :!ctags --extra=+f --exclude=.git --exclude=log --exclude=tags --exclude=doc --exclude=public -R * `bundle show --paths`<CR><C-M>
    " ctags usage:
    "   CTRL + ] to jump to method definition from a 'method call'
    "   CTRL + t to jump back from the method definition to the call

" }

" Abbreviations { --------------------------------------------------------
    iabbrev adn and
    iabbrev waht what
    iabbrev tehn then
    iabbrev -_- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    " ref: http://learnvimscriptthehardway.stevelosh.com/chapters/08.html
" }

" NERDTREE {--------------------------------------------------------------
    " [note] The following does not work
    "
    " function! NERDTreeMountPEdit()
    "     " from:> http://stackoverflow.com/questions/28396256/nerdtree-live-preview-like-sublime-sidebar
    "     if exists("g:loaded_nerdree_live_preview_mapping")
    "       finish
    "     endif
    "     let g:loaded_nerdree_live_preview_mapping = 1
    "
    "     call NERDTreeAddKeyMap({
    "           \ 'key':           '<up>',
    "           \ 'callback':      'NERDTreeLivePreview',
    "           \ 'quickhelpText': 'preview',
    "           \ })
    "
    "     function! NERDTreeLivePreview()
    "       " Get the path of the item under the cursor if possible:
    "       let current_file = g:NERDTreeFileNode.GetSelected()
    "
    "       if current_file == {}
    "         return
    "       else
    "         exe 'vert pedit '.current_file.path.str()
    "       endif
    "     endfunction
    " endfunction
" }

" Buffer {----------------------------------------------------------------
  " The following function delete all hidden buffers
  " from:> http://stackoverflow.com/questions/8450919/how-can-i-delete-all-hidden-buffers
  function! DeleteHiddenBuffers()
      let tpbl=[]
      call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')
      for buf in filter(range(1, bufnr('$')), 'bufexists(v:val) && index(tpbl, v:val)==-1')
          silent execute 'bwipeout' buf
      endfor
  endfunction
  command! Cdhbs call DeleteHiddenBuffers() <bar> :echo ":call DeleteHiddenBuffers()"


  " @TODO folllowing has not being implimented
  "
  "Close current buffer without close current window
  "from:> http://vim.wikia.com/wiki/Deleting_a_buffer_without_closing_the_window
  " nnoremap <leader>cc :Bclose<cr>
  "Other available commands:
  "   :Bclose         " Close buffer in current window.
  "   :Bclose N       " Close buffer number N (as shown by :ls).
  "   :Bclose Name    " Close buffer named Name (as shown by :ls).
"}


" NerdTree Preview {-------------------------------------------------
  "/ https://stackoverflow.com/questions/13119754/is-it-possible-to-just-view-files-content-when-traverse-nerdtree
  "/ https://stackoverflow.com/a/22183492/3136861
  let g:nerd_preview_enabled = 0
  let g:preview_last_buffer  = 0

  function! NerdTreePreview()
    " Only on nerdtree window
    if (&ft ==# 'nerdtree')
      " Get filename
      let l:filename = substitute(getline("."), "^\\s\\+\\|\\s\\+$","","g")

      " Preview if it is not a folder
      let l:lastchar = strpart(l:filename, strlen(l:filename) - 1, 1)
      if (l:lastchar != "/" && strpart(l:filename, 0 ,2) != "..")

        let l:store_buffer_to_close = 1
        if (bufnr(l:filename) > 0)
          " Don't close if the buffer is already open
          let l:store_buffer_to_close = 0
        endif

        " Do preview
        execute "normal go"

        " Close previews buffer
        if (g:preview_last_buffer > 0)
          execute "bwipeout " . g:preview_last_buffer
          let g:preview_last_buffer = 0
        endif

        " Set last buffer to close it later
        if (l:store_buffer_to_close)
          let g:preview_last_buffer = bufnr(l:filename)
        endif
      endif
    elseif (g:preview_last_buffer > 0)
      " Close last previewed buffer
      let g:preview_last_buffer = 0
    endif
  endfunction

  function! NerdPreviewToggle()
    echo 'preview Toggled'
    if (g:nerd_preview_enabled)
      let g:nerd_preview_enabled = 0
      augroup nerdpreview
        autocmd!
        augroup END
    else
      let g:nerd_preview_enabled = 1
      augroup nerdpreview
        autocmd!
        autocmd CursorMoved * nested call NerdTreePreview()
      augroup END
    endif
  endfunction

  command! CpreviewToggle call NerdPreviewToggle()
"}


" Yank filename/dirname {-------------------------------------------------
    " copy result to the system clipboard and echo the result
    " the cb> prompt means the clipboard
    "
    " File Name, eg. init.vim
    map <Leader>fn :let @+ = expand("%:t") \| echo 'cb> ' . @+<CR>
    " File Path, eg. /home/user/nvim/init.vim
    map <Leader>fp :let @+ = expand("%:p") \| echo 'cb> ' . @+<CR>
    " Directory Path, eg. /home/user/nvim
    map <Leader>dp :let @+ = expand("%:p:h") \| echo 'cb> ' . @+<CR>
    " Directory Name, eg. nvim
    map <Leader>dn :let @+ = expand("%:p:h:t") \| echo 'cb> ' . @+<CR>

    function! GetPath_full()
      " Full Path + filename + ext: eg. '/home/user/nvim/init.vim'
      let @+ = expand("%:p")
      echo 'cb> ' . @+
    endfunction
    command! CpathFull call GetPath_full()

    function! GetPath_base()
      " Filename + ext, eg: 'init.vim' in '/home/user/nvim/init.vim'
      let @+ = expand("%:t")
      echo 'cb> ' . @+
    endfunction
    command! CpathBase call GetPath_base()

    function! GetPath_dir()
      " Full dir path: eg. '/home/user/nvim' in '/home/user/nvim/init.vim'
      let @+ = expand("%:p:h")
      echo 'cb> ' . @+
    endfunction
    command! CpathDir call GetPath_dir()

    function! GetPath_DirTail()
      " Current Enclosing Dir Name, eg. 'nvim' in '/home/user/nvim/init.vim'
      let @+ = expand("%:p:h:t")
      echo 'cb> ' . @+
    endfunction
    command! CpathDirTail call GetPath_DirTail()

    " Ref: http://stackoverflow.com/questions/916875/yank-file-name-path-of-current-buffer-in-vim/37192216#37192216
" }


  "/ ***
  "/ *** YouCompleteMe
  "/ ***
    " "/ Valloric/YouCompleteMe {
    "   let g:ycm_error_symbol = '>'
    "   let g:ycm_warning_symbol = '•'
    "   nnoremap <leader>vvdd :YcmCompleter GoTo<CR>
    " "}



"/ Far plugin configuration {{{ ----------------------------------


  "/ --------------------------
  "/ Far uncomment the follwing
  "/ and restart vim to enable
  "/ far's debug mode
  "/ --------------------------
  "let g:far#debug = 1

  "/ --------------------
  "/ Far enabling ripgrep
  "/ --------------------
    "/ see: https://github.com/brooth/far.vim/issues/69
    command! CfarSrcRipgrep let g:far#source = 'rg' | echo 'g:far#source='.g:far#source
    command! CfarSrcVimgrep let g:far#source = 'vimgrep' | echo 'g:far#source='.g:far#source
    command! CfarSrcAg let g:far#source = 'ag' | echo 'g:far#source='.g:far#source
    command! CfarSrcCurrent echom g:far#source

  "/ ---------------------
  "/ Far working directory
  "/ ---------------------
    function! FarPwd()
      echom 'g:far#cwd: '.g:far#cwd
    endfunction "/ FarPwd()
    command! CfarPwd call FarPwd()

    function! FarCd()
      echom '[before] g:far#cwd='.g:far#cwd

      if !WINDOWS()
        "echom 'Runtime envrionment: Not windows'
        let _dir = system('pwd')
      endif
      if WINDOWS()
        "echom 'Runtime envrionment: Windows'
        let _dir = system('cd')
      endif

      "/ _dir contain the char '^@', remove it
      "/ Ref:
      "/    superuser.com/questions/935574/get-rid-of-null-character-in-vim-variable
      let g:far#cwd = substitute(_dir, '[[:cntrl:]]', '', 'g')

      echom '   [now] g:far#cwd='.g:far#cwd
    endfunction "/ FarCd()
    command! CfarCd call FarCd()

"/ Far plugin configuration END }}}

" Syntastic plugin { ----------------------------------------
    set statusline+=%#warningmsg#
    set statusline+=%{SyntasticStatuslineFlag()}
    set statusline+=%*

    let g:syntastic_always_populate_loc_list = 1
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_check_on_open = 0
    let g:syntastic_check_on_wq = 0
    let g:syntastic_javascript_checkers = ['eslint']
    let g:syntastic_typescript_checkers = ['tslint']

    " let g:syntastic_javascript_eslint_exe = 'npm run lint --'
    "/ The above from https://medium.com/@hpux/vim-and-eslint-16fa08cc580f
    "/ take too long to run so comment out

    "/ Disable Syntastic by default, to run syntax check, manually by typing :SyntasticCheck
    "/ https://stackoverflow.com/a/21434697/3136861
    let g:syntastic_mode_map = { 'mode': 'passive', 'active_filetypes': [],'passive_filetypes': [] }

" }



"/ wildignore {{{ ---------------------------------------------------------

  "/ Ref:
  "/  stackoverflow.com/questions/11978291/how-do-i-use-wildignore-in-vim
  "/  stackoverflow.com/questions/579871/can-i-make-vim-respect-my-gitignore-files/579886#579886
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/node_modules/*,*/dist/*
  " Windows ('noshellslash')

"/ }}}

" END .vimrc

